// --- Bluetooth setup (no pairing required recommended in project settings) ---
bluetooth.startUartService()
bluetooth.setTransmitPower(7)
basic.showIcon(IconNames.Heart)

// --- Helpers using Cutebot Pro extension ---
function capSigned(x: number) { return Math.max(-100, Math.min(100, Math.floor(x))) }
function setLR(l: number, r: number) {
    CutebotPro.pwmCruiseControl(capSigned(l), capSigned(r))  // supports -100..100
}
function stopMotors() { CutebotPro.pwmCruiseControl(0, 0) }

// --- Magnetometer hard-iron offsets (learned by CAL2) ---
let mxBias = 0
let myBias = 0
let mzBias = 0

// --- Heading streaming state ---
let streamHeading = false

// Degrees helper
function rad2deg(r: number) { return r * 180 / Math.PI }

// Normalize helper
function norm3(x: number, y: number, z: number) {
    const m = Math.sqrt(x * x + y * y + z * z) || 1
    return [x / m, y / m, z / m]
}

// Tilt-compensated heading (works when upright or tilted)
function getHeadingTiltComp(): number {
    // Raw magnetic field in µT with bias correction
    const mx = input.magneticForce(Dimension.X) - mxBias
    const my = input.magneticForce(Dimension.Y) - myBias
    const mz = input.magneticForce(Dimension.Z) - mzBias

    // Accel (for pitch/roll)
    const ax = input.acceleration(Dimension.X)
    const ay = input.acceleration(Dimension.Y)
    const az = input.acceleration(Dimension.Z)

    // Normalize accelerometer
    const n = norm3(ax, ay, az)
    const nx = n[0], ny = n[1], nz = n[2]

    // Compute roll and pitch from accelerometer
    // roll φ = atan2(ay, az)
    // pitch θ = atan2(-ax, sqrt(ay^2 + az^2))
    const roll = Math.atan2(ny, nz)
    const pitch = Math.atan2(-nx, Math.sqrt(ny * ny + nz * nz))

    // Tilt-compensate magnetometer
    // mx2 = mx*cosθ + mz*sinθ
    // my2 = mx*sinφ*sinθ + my*cosφ - mz*sinφ*cosθ
    const cosR = Math.cos(roll), sinR = Math.sin(roll)
    const cosP = Math.cos(pitch), sinP = Math.sin(pitch)

    const mx2 = mx * cosP + mz * sinP
    const my2 = mx * sinR * sinP + my * cosR - mz * sinR * cosP

    // Heading ψ = atan2(-my2, mx2), convert to 0..359
    let hdg = rad2deg(Math.atan2(-my2, mx2))
    if (hdg < 0) hdg += 360
    return Math.floor(hdg)
}

// Quick-and-dirty hard-iron calibration: rotate the bot for ~4s
function calibrateHardIron(ms: number = 4000) {
    let minX = 1e9, minY = 1e9, minZ = 1e9
    let maxX = -1e9, maxY = -1e9, maxZ = -1e9
    const t0 = control.millis()
    basic.showIcon(IconNames.Target)
    while (control.millis() - t0 < ms) {
        const x = input.magneticForce(Dimension.X)
        const y = input.magneticForce(Dimension.Y)
        const z = input.magneticForce(Dimension.Z)
        if (x < minX) minX = x; if (x > maxX) maxX = x
        if (y < minY) minY = y; if (y > maxY) maxY = y
        if (z < minZ) minZ = z; if (z > maxZ) maxZ = z
        basic.pause(20)
    }
    // Bias = center of ellipsoid (simple midpoint)
    mxBias = (minX + maxX) / 2
    myBias = (minY + maxY) / 2
    mzBias = (minZ + maxZ) / 2
    basic.showIcon(IconNames.Yes)
}

// Background task to stream heading when enabled
control.inBackground(function () {
    while (true) {
        if (streamHeading) {
            // Sample when motors are stopped for best results
            const h = getHeadingTiltComp()
            bluetooth.uartWriteLine("HEADING_TILT," + h)
        }
        basic.pause(200) // ~5 Hz
    }
})

// --- UART command protocol ---
//   V,<l>,<r>         -> set wheels (supports negatives)
//   T,<l>,<r>,<ms>    -> timed move then stop
//   F,<s> / B,<s>     -> forward/backward both wheels
//   S                 -> stop
//   LED,<icon>        -> HEART|HAPPY|SAD|SQUARE|DIAMOND|CLEAR
//   H                 -> one-shot tilt-comp heading: HEADING_TILT,<deg>
//   H,RAW             -> raw magnetometer: HRAW,x,y,z (µT, bias-corrected)
//   H,ON / H,OFF      -> start/stop streaming tilt-comp heading
//   CAL               -> built-in UI calibration (micro:bit dots)
//   CAL2              -> quick hard-iron bias learn (~4s rotate)
bluetooth.onUartDataReceived(serial.delimiters(Delimiters.NewLine), function () {
    const msg = bluetooth.uartReadUntil(serial.delimiters(Delimiters.NewLine)).trim()
    const p = msg.split(",")
    const cmd = p[0].toUpperCase()
    const num = (i: number, d = 0) => (p.length > i ? Math.floor(parseFloat(p[i])) : d)

    if (cmd == "V" && p.length >= 3) {
        setLR(num(1), num(2))
        bluetooth.uartWriteLine("OK V")
    } else if (cmd == "T" && p.length >= 4) {
        setLR(num(1), num(2))
        basic.pause(Math.max(0, num(3)))
        stopMotors()
        bluetooth.uartWriteLine("OK T")
    } else if (cmd == "F" && p.length >= 2) {
        const s = capSigned(num(1))
        setLR(s, s); bluetooth.uartWriteLine("OK F")
    } else if (cmd == "B" && p.length >= 2) {
        const s = capSigned(num(1))
        setLR(-Math.abs(s), -Math.abs(s)); bluetooth.uartWriteLine("OK B")
    } else if (cmd == "S") {
        stopMotors(); bluetooth.uartWriteLine("OK S")
    } else if (cmd == "LED" && p.length >= 2) {
        const icon = p[1].toUpperCase()
        if (icon == "HEART") basic.showIcon(IconNames.Heart)
        else if (icon == "HAPPY") basic.showIcon(IconNames.Happy)
        else if (icon == "SAD") basic.showIcon(IconNames.Sad)
        else if (icon == "SQUARE") basic.showIcon(IconNames.SmallSquare)
        else if (icon == "DIAMOND") basic.showIcon(IconNames.SmallDiamond)
        else if (icon == "CLEAR") basic.clearScreen()
        bluetooth.uartWriteLine("OK LED")
    } else if (cmd == "H") {
        const mode = (p.length >= 2) ? p[1].toUpperCase() : ""
        if (mode == "ON") { streamHeading = true; bluetooth.uartWriteLine("OK H,ON") }
        else if (mode == "OFF") { streamHeading = false; bluetooth.uartWriteLine("OK H,OFF") }
        else if (mode == "RAW") {
            const x = Math.round(input.magneticForce(Dimension.X) - mxBias)
            const y = Math.round(input.magneticForce(Dimension.Y) - myBias)
            const z = Math.round(input.magneticForce(Dimension.Z) - mzBias)
            bluetooth.uartWriteLine(`HRAW,${x},${y},${z}`)
        } else {
            const h = getHeadingTiltComp()
            bluetooth.uartWriteLine("HEADING_TILT," + h)
        }
    } else if (cmd == "CAL") {
        input.calibrateCompass()
        bluetooth.uartWriteLine("OK CAL")
    } else if (cmd == "CAL2") {
        calibrateHardIron(4000) // ~4s
        bluetooth.uartWriteLine(`OK CAL2,BIAS,${Math.round(mxBias)},${Math.round(myBias)},${Math.round(mzBias)}`)
    } else {
        bluetooth.uartWriteLine("ERR " + msg)
    }
})

// Connection indicators & safety
bluetooth.onBluetoothConnected(function () { basic.showString("C") })
bluetooth.onBluetoothDisconnected(function () { basic.showString("X"); stopMotors() })
stopMotors()
